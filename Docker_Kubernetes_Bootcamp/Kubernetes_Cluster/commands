This gets recorded in a kubectl configuration file, usually located at $HOME/.kube/config.  

$ kubectl config set-context my-context --namespace=mystuff 


$ kubectl config use-context my-context

$ kubectl get pods,services

$ kubectl describe <resource-name> <obj-name>

$ kubectl explain pods

$ kubectl apply -f obj.yaml


use the --dry-run flag to print the objects to the terminal without actually sending them to the server

$ kubectl delete -f obj.yaml

$ kubectl logs <pod-name>

$ kubectl exec -it <pod-name> -- bash

$ kubectl cp <pod-name>:</path/to/remote/file> </path/to/local/file>

If you donâ€™t have bash or some other terminal available within your container, you can always attach to the running process:

$ kubectl attach -it <pod-name>

$ kubectl port-forward <pod-name> 8080:80

$ kubectl get events

$ kubectl top nodes

$ kubectl top pods


The kubectl tool can also be used to manage the cluster itself. The most common action that people take to manage their cluster is to cordon and drain a particular node. When you cordon a node, you prevent future Pods from being scheduled onto that machine. When you drain a node, you remove any Pods that are currently running on that machine. 

# macOS
$ brew install bash-completion

# CentOS/Red Hat
$ yum install bash-completion

$ kubectl describe pods kuard

$ kubectl delete -f kuard-pod.yaml

$ kubectl logs kuard

$ kubectl exec kuard -- date


$ kubectl run bandicoot-prod \
  --image=gcr.io/kuar-demo/kuard-amd64:green \
  --replicas=2 \
  --labels="ver=2,app=bandicoot,env=prod"
  
$ kubectl run bandicoot-staging \
  --image=gcr.io/kuar-demo/kuard-amd64:green \
  --replicas=1 \
  --labels="ver=2,app=bandicoot,env=staging"